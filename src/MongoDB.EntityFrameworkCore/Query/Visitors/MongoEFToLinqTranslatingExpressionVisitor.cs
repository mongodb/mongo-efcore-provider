/* Copyright 2023-present MongoDB Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Query;
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Serializers;
using MongoDB.Driver.Linq;

namespace MongoDB.EntityFrameworkCore.Query.Visitors;

/// <summary>
/// Visits the tree resolving any query context parameter bindings and EF references so the query can be used with the MongoDB V3 LINQ provider.
/// </summary>
internal sealed class MongoEFToLinqTranslatingExpressionVisitor : ExpressionVisitor
{
    private readonly QueryContext _queryContext;
    private readonly Expression _source;

    internal MongoEFToLinqTranslatingExpressionVisitor(
        QueryContext queryContext,
        Expression source)
    {
        _queryContext = queryContext;
        _source = source;
    }

    public MethodCallExpression Translate(
        Expression? efQueryExpression,
        ResultCardinality resultCardinality)
    {
        if (efQueryExpression == null) // No LINQ methods, e.g. Direct ToList() against DbSet
        {
            return InjectAsBsonDocumentMethod(_source, BsonDocumentSerializer.Instance);
        }

        var query = (MethodCallExpression)Visit(efQueryExpression)!;

        if (resultCardinality == ResultCardinality.Enumerable)
        {
            return InjectAsBsonDocumentMethod(query, BsonDocumentSerializer.Instance);
        }

        var documentQueryableSource = InjectAsBsonDocumentMethod(query.Arguments[0], BsonDocumentSerializer.Instance);

        return Expression.Call(
            null,
            query.Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(BsonDocument)),
            documentQueryableSource);
    }

    private static MethodCallExpression InjectAsBsonDocumentMethod(
        Expression query,
        BsonDocumentSerializer resultSerializer)
    {
        var asMethodInfo = __asMethodInfo.MakeGenericMethod(query.Type.GenericTypeArguments[0], typeof(BsonDocument));
        var cast = Expression.Convert(query, typeof(IMongoQueryable<>).MakeGenericType(query.Type.GenericTypeArguments[0]));
        var serializerExpression = Expression.Constant(resultSerializer, resultSerializer.GetType());

        return Expression.Call(
            null,
            asMethodInfo,
            cast,
            serializerExpression
        );
    }

    public override Expression? Visit(Expression? expression)
    {
        switch (expression)
        {
            // Replace the QueryContext parameter values with constant values for this execution.
            case ParameterExpression parameterExpression:
                if (parameterExpression.Name?.StartsWith(QueryCompilationContext.QueryParameterPrefix, StringComparison.Ordinal)
                    == true)
                {
                    return Expression.Constant(_queryContext.ParameterValues[parameterExpression.Name]);
                }

                break;

            // Replace object.Equals(Property(p, "propName"), ConstantExpression) elements generated by EF's Find.
            case MethodCallExpression {Method.Name: nameof(object.Equals), Object: null, Arguments.Count: 2} methodCallExpression:
                var left = Visit(RemoveObjectConvert(methodCallExpression.Arguments[0]))!;
                var leftType = methodCallExpression.Method.GetParameters()[0].ParameterType;
                var right = Visit(RemoveObjectConvert(methodCallExpression.Arguments[1]))!;
                var rightType = methodCallExpression.Method.GetParameters()[0].ParameterType;

                return Expression.Call(null, methodCallExpression.Method, ConvertIfRequired(left, leftType),
                    ConvertIfRequired(right, rightType));

            // Replace EF-generated Property(p, "propName") with p.propName.
            case MethodCallExpression methodCallExpression
                when methodCallExpression.Method.IsEFPropertyMethod()
                     && methodCallExpression.Arguments[1] is ConstantExpression propertyNameExpression:
                var source = methodCallExpression.Arguments[0];
                var property = source.Type.GetProperties()
                    .First(prop => prop.Name == propertyNameExpression.GetConstantValue<string>());
                var propertyExpression = Expression.Property(source, property);

                return methodCallExpression.Method.ReturnType != property.PropertyType
                    ? Expression.Convert(propertyExpression, methodCallExpression.Method.ReturnType)
                    : propertyExpression;

            // Unwrap include expressions.
            case IncludeExpression includeExpression:
                return Visit(includeExpression.EntityExpression);

            // Replace the root with the MongoDB LINQ V3 provider source.
            case EntityQueryRootExpression:
                return _source;
        }

        return base.Visit(expression);
    }

    private static Expression ConvertIfRequired(Expression expression, Type targetType) =>
        expression.Type == targetType ? expression : Expression.Convert(expression, targetType);

    private static Expression RemoveObjectConvert(Expression expression)
        => expression is UnaryExpression {NodeType: ExpressionType.Convert or ExpressionType.ConvertChecked} unaryExpression
           && unaryExpression.Type == typeof(object)
            ? unaryExpression.Operand
            : expression;

    private static readonly MethodInfo __asMethodInfo = typeof(MongoQueryable)
        .GetMethods()
        .First(mi => mi is {Name: nameof(MongoQueryable.As), IsPublic: true, IsStatic: true} && mi.GetParameters().Length == 2);
}
